Name: Anubhavnidhi Abhashkumar
CSL-ID: anubhavnidhi
<<<<<<< HEAD
Name: Rasiga Gowrisankar
CSL-ID: rasiga
Implementation Details:
			In this program, we first check if there is a tee(%) command or pipe command(|). If there are no such command then we execute the command in a child (after forking) using a execvp call. Also if there is a redirection(>) or append(>>), then we close the standard output and open a file (whose name is mentioned in the right hand side of > or >>). If there is a single pipe command, then we create 2 child processes. In the first child we execute the left hand side of the pipe and instead of writing to output we put into a pipe. The second process takes an input from the same pipe and then execute the right side of pipe (and print it to the output). If there is are two pipe command, then we create 3 child processes. In the first child we execute the left most command (left of the first pipe) and instead of writing to output we put into a pipe1. The second process takes an input from the same pipe1 and then execute the command in the middle part of the program, also the output is put into another pipe2. Finally the third process reads from pipe2, executes the rightmost command (right of the second pipe). If it is a tee command, then also we create 3 child processes. In the first child we execute the left hand side of the tee command and instead of writing to output we put into a pipe1. The second process takes an input from the same pipe1 and the mytee c program which writes the pipe1 output into a file named tee.txt and also send it into another pipe2. Finally the third process reads from pipe2, executes the right hand side of the tee command. Also if the command is an exit command then we use the exit system call, if it is pwd then using getpwd we print the path it in the program or if it is a cd command then we use chdir to change directory.  
=======

Implementation Details:
			To count the number of process running in xv6, I have to go through the ptable and count all the processes which are not in unused state.
                        For this program, I had to do changes to the following files: include/syscall.h, user/user.h, user/usys.S, kernel/sysfunc.h, kernel/syscall.c, kernel/sysproc.c, kernel/proc.h and kernel/proc.c. Most of it was done by seeing how getpid was implemented.

In include/syscall.h, I added the system call number for SYS_getprocs

In user/user.h, I added the definition for the system call getprocs()

In user/usys.S, I added SYSCALL(getprocs). This file is responsible for doing an interrupt and specifying which system call to execute (converts to sys_getprocs).

In kernel/sysfunc.h, I added the definition for the system call sys_getprocs()

I added the function pointer (for sys_getprocs) to the array of function pointers in kernel/syscall.c. This is responsible for trap handling.

For this program I had to traverse the processes in ptable which is present in kernel/proc.c. So I create a function called num_process and call it from (kernel/sysproc.c) sys_getprocs()

In kernel/proc.h, I write the definition for num_process()

In num_process() at kernel/proc.c, I mimic the scheduler() function. I initialize a counter to 0 and go through the processes in ptable where I increment the counter if the process is not in unused state and finally return the counter value.

Like mentioned on piazza, if the state of proc is neither of the following: UNUSED, RUNNING, RUNNABLE, EMBRYO, SLEEPING, ZOMBIE then I return -1. Also if init, sh processes are not present I return -1. 
>>>>>>> 6250f6ff114f8326bf6264e86dc2f681bbcce8ca
